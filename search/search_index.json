{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Seja bem vindo(a)! Este modelo adota o padr\u00e3o Markdown. Para mais detalhes com mkdocs, clique aqui . Configura\u00e7\u00e3o do Mkdocs, Material e Mermaid pip3 install mkdocs mkdocs-material mkdocs-mermaid2-plugin Comandos para documenta\u00e7\u00e3o com Mkdocs mkdocs new [dir-name] - Cria um novo projeto. mkdocs gh-deploy - Realiza a implanta\u00e7\u00e3o do reposit\u00f3rio corrente atrav\u00e9s de p\u00e1gina web no servidor do github. mkdocs serve - Inicia um servidor web com a p\u00e1gina do reposit\u00f3rio. mkdocs build - Realiza a gera\u00e7\u00e3o da documenta\u00e7\u00e3o web. mkdocs -h - Imprime mensagem de ajuda. Modelos de documentos Os seguintes t\u00f3picos apresentam modelos de documentos acad\u00eamicos usando markdown. Relat\u00f3rio O modelo de relat\u00f3rio \u00e9 destinado aos mais diversos tipos de documenta\u00e7\u00e3o Artigo O modelo de artigo \u00e9 destinado para para trabalhos de disciplinas e publica\u00e7\u00e3o em eventos. Livro O modelo de livro est\u00e1 em elabora\u00e7\u00e3o. Apresenta\u00e7\u00e3o com slides O modelo de apresenta\u00e7\u00e3o est\u00e1 em elabora\u00e7\u00e3o. Gera\u00e7\u00e3o dos resultados Um comando para gera\u00e7\u00e3o simples de PDF \u00e9: $pandoc example1.md -o out/example1.pdf --filter=pandoc-fignos --filter=pandoc-eqnos --filter=pandoc-tablenos --filter=pandoc-citeproc I Reposit\u00f3rios de refer\u00eancias O reposit\u00f3rio pandoc-examples cont\u00e9m v\u00e1rios outros modelos de markdown \u00fateis. $git clone https://github.com/kikofernandez/pandoc-examples O reposit\u00f3rio pandoc-scholar cont\u00e9m subs\u00eddios para gera\u00e7\u00e3o do c\u00f3digo, usando docker e exemplos \u00fateis. $git clone https://github.com/pandoc-scholar/pandoc-scholar O reposit\u00f3rio seguinte cont\u00e9m um modelo simples de artigo com markdown e suporte a refer\u00eancias. $git clone https://github.com/andrewmarx/paper-template O reposit\u00f3rio seguinte cont\u00e9m um modelo de livro. $git clone https://github.com/mattcone/markdown-guide-book","title":"Seja bem vindo(a)!"},{"location":"#seja-bem-vindoa","text":"Este modelo adota o padr\u00e3o Markdown. Para mais detalhes com mkdocs, clique aqui .","title":"Seja bem vindo(a)!"},{"location":"#configuracao-do-mkdocs-material-e-mermaid","text":"pip3 install mkdocs mkdocs-material mkdocs-mermaid2-plugin","title":"Configura\u00e7\u00e3o do Mkdocs, Material e Mermaid"},{"location":"#comandos-para-documentacao-com-mkdocs","text":"mkdocs new [dir-name] - Cria um novo projeto. mkdocs gh-deploy - Realiza a implanta\u00e7\u00e3o do reposit\u00f3rio corrente atrav\u00e9s de p\u00e1gina web no servidor do github. mkdocs serve - Inicia um servidor web com a p\u00e1gina do reposit\u00f3rio. mkdocs build - Realiza a gera\u00e7\u00e3o da documenta\u00e7\u00e3o web. mkdocs -h - Imprime mensagem de ajuda.","title":"Comandos para documenta\u00e7\u00e3o com Mkdocs"},{"location":"#modelos-de-documentos","text":"Os seguintes t\u00f3picos apresentam modelos de documentos acad\u00eamicos usando markdown.","title":"Modelos de documentos"},{"location":"#relatorio","text":"O modelo de relat\u00f3rio \u00e9 destinado aos mais diversos tipos de documenta\u00e7\u00e3o","title":"Relat\u00f3rio"},{"location":"#artigo","text":"O modelo de artigo \u00e9 destinado para para trabalhos de disciplinas e publica\u00e7\u00e3o em eventos.","title":"Artigo"},{"location":"#livro","text":"O modelo de livro est\u00e1 em elabora\u00e7\u00e3o.","title":"Livro"},{"location":"#apresentacao-com-slides","text":"O modelo de apresenta\u00e7\u00e3o est\u00e1 em elabora\u00e7\u00e3o.","title":"Apresenta\u00e7\u00e3o com slides"},{"location":"#geracao-dos-resultados","text":"Um comando para gera\u00e7\u00e3o simples de PDF \u00e9: $pandoc example1.md -o out/example1.pdf --filter=pandoc-fignos --filter=pandoc-eqnos --filter=pandoc-tablenos --filter=pandoc-citeproc I","title":"Gera\u00e7\u00e3o dos resultados"},{"location":"#repositorios-de-referencias","text":"O reposit\u00f3rio pandoc-examples cont\u00e9m v\u00e1rios outros modelos de markdown \u00fateis. $git clone https://github.com/kikofernandez/pandoc-examples O reposit\u00f3rio pandoc-scholar cont\u00e9m subs\u00eddios para gera\u00e7\u00e3o do c\u00f3digo, usando docker e exemplos \u00fateis. $git clone https://github.com/pandoc-scholar/pandoc-scholar O reposit\u00f3rio seguinte cont\u00e9m um modelo simples de artigo com markdown e suporte a refer\u00eancias. $git clone https://github.com/andrewmarx/paper-template O reposit\u00f3rio seguinte cont\u00e9m um modelo de livro. $git clone https://github.com/mattcone/markdown-guide-book","title":"Reposit\u00f3rios de refer\u00eancias"},{"location":"exemplos/","text":"Exemplos b\u00e1sicos com Markdown Mermaid permite criar e visualizar diagramas. Este exemplo \u00e9 um modelo de cronograma simples, documenta\u00e7\u00e3o sobre o gr\u00e1fico de est\u00e1 dispon\u00edvel aqui . gantt title Cronograma de atividades do projeto dateFormat YYYY-MM-DD section Documenta\u00e7\u00e3o Pr\u00e9-projeto :a1, 2022-05-24, 15d Levantamento de literatura :a2,after a1 , 20d Escrita da parte te\u00f3rica :a3,after a2, 7d section Prototipa\u00e7\u00e3o Cria\u00e7\u00e3o de telas do sistema :c2,2022-06-10 , 12d Cria\u00e7\u00e3o do prot\u00f3tipo :c3,after c2, 14d section Defesa Prepara\u00e7\u00e3o dos slides :p1, 2022-07-01, 10d Ensaio da apresenta\u00e7\u00e3o :p2, 2022-07-07, 7d O cronograma pode prever os seguintes t\u00f3picos sugeridos: - Levantamento da literatura: quanto tempo voc\u00ea demora para ler e organizar as refer\u00eancias bibliogr\u00e1ficas? - Escolha do instrumento e prepara\u00e7\u00e3o para coleta de dados: quanto tempo ser\u00e1 gasto para escolher os instrumentos que ser\u00e3o usados na pesquisa? (Question\u00e1rios, entrevistas e escalas, por exemplo). - Levantamento de dados: quanto tempo \u00e9 preciso para levantar os dados que ser\u00e3o usados no estudo? - Escrita da parte te\u00f3rica: quanto tempo ser\u00e1 gasto para escrever o relat\u00f3rio? - An\u00e1lise dos dados: qual \u00e9 o tempo necess\u00e1rio para organizar os dados coletados em planilhas e tabul\u00e1-los? - Discuss\u00e3o dos resultados: quanto tempo voc\u00ea vai gastar para articular os seus dados com os dados de outros autores que pesquisaram as mesmas vari\u00e1veis? - Elabora\u00e7\u00e3o da conclus\u00e3o e refer\u00eancias: quanto tempo \u00e9 necess\u00e1rio para escrever as considera\u00e7\u00f5es finais e colocar a lista de refer\u00eancias bibliogr\u00e1ficas nas normas da ABNT? - Ajustes finais: de quanto tempo voc\u00ea precisa para revisar a formata\u00e7\u00e3o? - Cria\u00e7\u00e3o da apresenta\u00e7\u00e3o: qual \u00e9 o tempo necess\u00e1rio para elaborar os slides e ensaiar a apresenta\u00e7\u00e3o? - Defesa: Quando o trabalho ser\u00e1 apresentado para a banca? graph TD A[Christmas] -->|Get money| B(Go shopping) B --> C{Let me think} C -->|One| D[Laptop] C -->|Two| E[iPhone] C -->|Three| F[fa:fa-car Car] Diagrama de classes classDiagram Animal <|-- Duck Animal <|-- Fish Animal <|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } Para representar outros diagramas consulte Mermaid's Syntax . Uma se\u00e7\u00e3o comprimida contendo Markdown Clique para expandir! ## Heading 1. A numbered 2. list * With some * Sub bullets Uma se\u00e7\u00e3o comprimida contendo c\u00f3digo Clique para expandir! ```javascript function logSometing(something) { console.log(`Logging: ${something}`); } ``` Mermaid is a Javascript based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development. Doc-Rot is a Catch-22 that Mermaid helps to solve. Diagramming and documentation costs precious developer time and gets outdated quickly. But not having diagrams or docs ruins productivity and hurts organizational learning. Mermaid addresses this problem by enabling users to create easily modifiable diagrams, it can also be made part of production scripts (and other pieces of code). Mermaid allows even non-programmers to easily create detailed and diagrams through the Mermaid Live Editor . Tutorials has video tutorials. Use Mermaid with your favorite applications, check out the list of Integrations and Usages of Mermaid . For a more detailed introduction to Mermaid and some of its more basic uses, look to the Beginner's Guide and Usage . \ud83c\udf10 CDN | \ud83d\udcd6 Documentation | \ud83d\ude4c Contribution | \ud83d\udcdc Version Log | \ud83d\udd0c Plug-Ins \ud83d\udd96 Keep a steady pulse: mermaid needs more Collaborators, Read More . :trophy: Mermaid was nominated and won the JS Open Source Awards (2019) in the category \"The most exciting use of technology\"!!! Thanks to all involved, people committing pull requests, people answering questions and special thanks to Tyler Long who is helping me maintain the project \ud83d\ude4f In our release process we rely heavily on visual regression tests using applitools . Applitools is a great service which has been easy to use and integrate with our tests. Diagram Types Flowchart graph TD; A-->B; A-->C; B-->D; C-->D; Sequence diagram sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts <br/>prevail! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! Gantt diagram gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d Class diagram classDiagram Class01 <|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --> C2 : Where am i? Class09 --* C3 Class09 --|> Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 <--> C2: Cool label Git graph gitGraph commit commit branch develop commit commit commit checkout main commit commit Entity Relationship Diagram - :exclamation: experimental erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses User Journey Diagram journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me Installation In depth guides and examples can be found at Getting Started and Usage . It would also be helpful to learn more about mermaid's Syntax . CDN https://unpkg.com/mermaid@<version>/dist/ To select a version: Replace <version> with the desired version number. Latest Version: https://unpkg.com/browse/mermaid@8.8.0/ Deploying Mermaid To Deploy Mermaid: You will need to install node v16, which would have npm Download yarn using npm Enter the following command: yarn add mermaid You can then add mermaid as a dev dependency using this command: yarn add --dev mermaid Mermaid API : To deploy mermaid without a bundler, one can insert a script tag with an absolute address and a mermaidAPI call into the HTML like so: <script src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"></script> <script>mermaid.initialize({startOnLoad:true}); </script> Doing so will command the mermaid parser to look for the <div> tags with class=\"mermaid\" . From these tags mermaid will try to read the diagram/chart definitions and render them into svg charts. Examples can be found at Other examples Sibling projects Mermaid Live Editor Mermaid CLI Mermaid Webpack Demo Mermaid Parcel Demo Request for Assistance Things are piling up and I have a hard time keeping up. It would be great if we could form a core team of developers to cooperate with the future development of mermaid. As part of this team you would get write access to the repository and would represent the project when answering questions and issues. Together we could continue the work with things like: Adding more types of diagrams like mindmaps, ert diagrams, etc. Improving existing diagrams Don't hesitate to contact me if you want to get involved! For contributors Setup yarn install Build yarn build:watch Lint yarn lint We use eslint . We recommend you to install editor plugins to get real time lint result. Test yarn test Manual test in browser: open dist/index.html Release For those who have the permission to do so: Update version number in package.json . npm publish The above command generates files into the dist folder and publishes them to npmjs.org. Related projects Command Line Interface Live Editor HTTP Server Contributors Mermaid is a growing community and is always accepting new contributors. There's a lot of different ways to help out and we're always looking for extra hands! Look at this issue if you want to know where to start helping out. Detailed information about how to contribute can be found in the contribution guide Security and safe diagrams For public sites, it can be precarious to retrieve text from users on the internet, storing that content for presentation in a browser at a later stage. The reason is that the user content can contain embedded malicious scripts that will run when the data is presented. For Mermaid this is a risk, specially as mermaid diagrams contain many characters that are used in html which makes the standard sanitation unusable as it also breaks the diagrams. We still make an effort to sanitise the incoming code and keep refining the process but it is hard to guarantee that there are no loop holes. As an extra level of security for sites with external users we are happy to introduce a new security level in which the diagram is rendered in a sandboxed iframe preventing javascript in the code from being executed. This is a great step forward for better security. Unfortunately you can not have a cake and eat it at the same time which in this case means that some of the interactive functionality gets blocked along with the possible malicious code. Reporting vulnerabilities To report a vulnerability, please e-mail security@mermaid.live with a description of the issue, the steps you took to create the issue, affected versions, and if known, mitigations for the issue. Appreciation A quick note from Knut Sveidqvist: Many thanks to the d3 and dagre-d3 projects for providing the graphical layout and drawing libraries! Thanks also to the js-sequence-diagram project for usage of the grammar for the sequence diagrams. Thanks to Jessica Peter for inspiration and starting point for gantt rendering. Thank you to Tyler Long who has been a collaborator since April 2017. Thank you to the ever-growing list of contributors that brought the project this far! Mermaid was created by Knut Sveidqvist for easier documentation.","title":"Exemplos b\u00e1sicos com Markdown"},{"location":"exemplos/#exemplos-basicos-com-markdown","text":"Mermaid permite criar e visualizar diagramas. Este exemplo \u00e9 um modelo de cronograma simples, documenta\u00e7\u00e3o sobre o gr\u00e1fico de est\u00e1 dispon\u00edvel aqui . gantt title Cronograma de atividades do projeto dateFormat YYYY-MM-DD section Documenta\u00e7\u00e3o Pr\u00e9-projeto :a1, 2022-05-24, 15d Levantamento de literatura :a2,after a1 , 20d Escrita da parte te\u00f3rica :a3,after a2, 7d section Prototipa\u00e7\u00e3o Cria\u00e7\u00e3o de telas do sistema :c2,2022-06-10 , 12d Cria\u00e7\u00e3o do prot\u00f3tipo :c3,after c2, 14d section Defesa Prepara\u00e7\u00e3o dos slides :p1, 2022-07-01, 10d Ensaio da apresenta\u00e7\u00e3o :p2, 2022-07-07, 7d O cronograma pode prever os seguintes t\u00f3picos sugeridos: - Levantamento da literatura: quanto tempo voc\u00ea demora para ler e organizar as refer\u00eancias bibliogr\u00e1ficas? - Escolha do instrumento e prepara\u00e7\u00e3o para coleta de dados: quanto tempo ser\u00e1 gasto para escolher os instrumentos que ser\u00e3o usados na pesquisa? (Question\u00e1rios, entrevistas e escalas, por exemplo). - Levantamento de dados: quanto tempo \u00e9 preciso para levantar os dados que ser\u00e3o usados no estudo? - Escrita da parte te\u00f3rica: quanto tempo ser\u00e1 gasto para escrever o relat\u00f3rio? - An\u00e1lise dos dados: qual \u00e9 o tempo necess\u00e1rio para organizar os dados coletados em planilhas e tabul\u00e1-los? - Discuss\u00e3o dos resultados: quanto tempo voc\u00ea vai gastar para articular os seus dados com os dados de outros autores que pesquisaram as mesmas vari\u00e1veis? - Elabora\u00e7\u00e3o da conclus\u00e3o e refer\u00eancias: quanto tempo \u00e9 necess\u00e1rio para escrever as considera\u00e7\u00f5es finais e colocar a lista de refer\u00eancias bibliogr\u00e1ficas nas normas da ABNT? - Ajustes finais: de quanto tempo voc\u00ea precisa para revisar a formata\u00e7\u00e3o? - Cria\u00e7\u00e3o da apresenta\u00e7\u00e3o: qual \u00e9 o tempo necess\u00e1rio para elaborar os slides e ensaiar a apresenta\u00e7\u00e3o? - Defesa: Quando o trabalho ser\u00e1 apresentado para a banca? graph TD A[Christmas] -->|Get money| B(Go shopping) B --> C{Let me think} C -->|One| D[Laptop] C -->|Two| E[iPhone] C -->|Three| F[fa:fa-car Car] Diagrama de classes classDiagram Animal <|-- Duck Animal <|-- Fish Animal <|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } Para representar outros diagramas consulte Mermaid's Syntax .","title":"Exemplos b\u00e1sicos com Markdown"},{"location":"exemplos/#uma-secao-comprimida-contendo-markdown","text":"Clique para expandir! ## Heading 1. A numbered 2. list * With some * Sub bullets","title":"Uma se\u00e7\u00e3o comprimida contendo Markdown"},{"location":"exemplos/#uma-secao-comprimida-contendo-codigo","text":"Clique para expandir! ```javascript function logSometing(something) { console.log(`Logging: ${something}`); } ``` Mermaid is a Javascript based diagramming and charting tool that uses Markdown-inspired text definitions and a renderer to create and modify complex diagrams. The main purpose of Mermaid is to help documentation catch up with development. Doc-Rot is a Catch-22 that Mermaid helps to solve. Diagramming and documentation costs precious developer time and gets outdated quickly. But not having diagrams or docs ruins productivity and hurts organizational learning. Mermaid addresses this problem by enabling users to create easily modifiable diagrams, it can also be made part of production scripts (and other pieces of code). Mermaid allows even non-programmers to easily create detailed and diagrams through the Mermaid Live Editor . Tutorials has video tutorials. Use Mermaid with your favorite applications, check out the list of Integrations and Usages of Mermaid . For a more detailed introduction to Mermaid and some of its more basic uses, look to the Beginner's Guide and Usage . \ud83c\udf10 CDN | \ud83d\udcd6 Documentation | \ud83d\ude4c Contribution | \ud83d\udcdc Version Log | \ud83d\udd0c Plug-Ins \ud83d\udd96 Keep a steady pulse: mermaid needs more Collaborators, Read More . :trophy: Mermaid was nominated and won the JS Open Source Awards (2019) in the category \"The most exciting use of technology\"!!! Thanks to all involved, people committing pull requests, people answering questions and special thanks to Tyler Long who is helping me maintain the project \ud83d\ude4f In our release process we rely heavily on visual regression tests using applitools . Applitools is a great service which has been easy to use and integrate with our tests.","title":"Uma se\u00e7\u00e3o comprimida contendo c\u00f3digo"},{"location":"exemplos/#diagram-types","text":"","title":"Diagram Types"},{"location":"exemplos/#flowchart","text":"graph TD; A-->B; A-->C; B-->D; C-->D;","title":"Flowchart"},{"location":"exemplos/#sequence-diagram","text":"sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts <br/>prevail! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good!","title":"Sequence diagram"},{"location":"exemplos/#gantt-diagram","text":"gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d","title":"Gantt diagram"},{"location":"exemplos/#class-diagram","text":"classDiagram Class01 <|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --> C2 : Where am i? Class09 --* C3 Class09 --|> Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 <--> C2: Cool label","title":"Class diagram"},{"location":"exemplos/#git-graph","text":"gitGraph commit commit branch develop commit commit commit checkout main commit commit","title":"Git graph"},{"location":"exemplos/#entity-relationship-diagram-exclamation-experimental","text":"erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses","title":"Entity Relationship Diagram - :exclamation: experimental"},{"location":"exemplos/#user-journey-diagram","text":"journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me","title":"User Journey Diagram"},{"location":"exemplos/#installation","text":"In depth guides and examples can be found at Getting Started and Usage . It would also be helpful to learn more about mermaid's Syntax .","title":"Installation"},{"location":"exemplos/#cdn","text":"https://unpkg.com/mermaid@<version>/dist/ To select a version: Replace <version> with the desired version number. Latest Version: https://unpkg.com/browse/mermaid@8.8.0/","title":"CDN"},{"location":"exemplos/#deploying-mermaid","text":"To Deploy Mermaid: You will need to install node v16, which would have npm Download yarn using npm Enter the following command: yarn add mermaid You can then add mermaid as a dev dependency using this command: yarn add --dev mermaid","title":"Deploying Mermaid"},{"location":"exemplos/#mermaid-api","text":"To deploy mermaid without a bundler, one can insert a script tag with an absolute address and a mermaidAPI call into the HTML like so: <script src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"></script> <script>mermaid.initialize({startOnLoad:true}); </script> Doing so will command the mermaid parser to look for the <div> tags with class=\"mermaid\" . From these tags mermaid will try to read the diagram/chart definitions and render them into svg charts. Examples can be found at Other examples","title":"Mermaid API:"},{"location":"exemplos/#sibling-projects","text":"Mermaid Live Editor Mermaid CLI Mermaid Webpack Demo Mermaid Parcel Demo","title":"Sibling projects"},{"location":"exemplos/#request-for-assistance","text":"Things are piling up and I have a hard time keeping up. It would be great if we could form a core team of developers to cooperate with the future development of mermaid. As part of this team you would get write access to the repository and would represent the project when answering questions and issues. Together we could continue the work with things like: Adding more types of diagrams like mindmaps, ert diagrams, etc. Improving existing diagrams Don't hesitate to contact me if you want to get involved!","title":"Request for Assistance"},{"location":"exemplos/#for-contributors","text":"","title":"For contributors"},{"location":"exemplos/#setup","text":"yarn install","title":"Setup"},{"location":"exemplos/#build","text":"yarn build:watch","title":"Build"},{"location":"exemplos/#lint","text":"yarn lint We use eslint . We recommend you to install editor plugins to get real time lint result.","title":"Lint"},{"location":"exemplos/#test","text":"yarn test Manual test in browser: open dist/index.html","title":"Test"},{"location":"exemplos/#release","text":"For those who have the permission to do so: Update version number in package.json . npm publish The above command generates files into the dist folder and publishes them to npmjs.org.","title":"Release"},{"location":"exemplos/#related-projects","text":"Command Line Interface Live Editor HTTP Server","title":"Related projects"},{"location":"exemplos/#contributors","text":"Mermaid is a growing community and is always accepting new contributors. There's a lot of different ways to help out and we're always looking for extra hands! Look at this issue if you want to know where to start helping out. Detailed information about how to contribute can be found in the contribution guide","title":"Contributors"},{"location":"exemplos/#security-and-safe-diagrams","text":"For public sites, it can be precarious to retrieve text from users on the internet, storing that content for presentation in a browser at a later stage. The reason is that the user content can contain embedded malicious scripts that will run when the data is presented. For Mermaid this is a risk, specially as mermaid diagrams contain many characters that are used in html which makes the standard sanitation unusable as it also breaks the diagrams. We still make an effort to sanitise the incoming code and keep refining the process but it is hard to guarantee that there are no loop holes. As an extra level of security for sites with external users we are happy to introduce a new security level in which the diagram is rendered in a sandboxed iframe preventing javascript in the code from being executed. This is a great step forward for better security. Unfortunately you can not have a cake and eat it at the same time which in this case means that some of the interactive functionality gets blocked along with the possible malicious code.","title":"Security and safe diagrams"},{"location":"exemplos/#reporting-vulnerabilities","text":"To report a vulnerability, please e-mail security@mermaid.live with a description of the issue, the steps you took to create the issue, affected versions, and if known, mitigations for the issue.","title":"Reporting vulnerabilities"},{"location":"exemplos/#appreciation","text":"A quick note from Knut Sveidqvist: Many thanks to the d3 and dagre-d3 projects for providing the graphical layout and drawing libraries! Thanks also to the js-sequence-diagram project for usage of the grammar for the sequence diagrams. Thanks to Jessica Peter for inspiration and starting point for gantt rendering. Thank you to Tyler Long who has been a collaborator since April 2017. Thank you to the ever-growing list of contributors that brought the project this far! Mermaid was created by Knut Sveidqvist for easier documentation.","title":"Appreciation"},{"location":"Modelos/Relatorio/relatorio/","text":".warning { background: beige; padding: 10px; } Researchers who influenced the type checker design Stephan Brandauer, Dave Clarke, Albert Mingkun Yang, and Tobias Wrigstad Description This artefact contains an incremental implementation of the type checker as explained in the paper . This document contains the following: information on how to build the library, explanations and documentation of the main functions of the type checking library, unit tests, detailed information on writing your own programs and type checking them, a new section that can be thought as a preliminary approach to Section 7 of the paper, which is a simplification that removes certain abstractions for the non-advanced Haskell reader, and information on how to extend the type checker. NOTE . We recommend that the reader looks at the HTML version of the README file, since it is better formatted and the links point to PDF sections automatically. One can find the HTML version in the downloaded artefact, inside the zip file. Table of Contents: Folder Structure Prerequisites i) Installing prerequisites on OSX ii) Installing prerequisites on Linux iii) Installing prerequisites on Windows iv) Using a provisioned Virtual Machine Implementation in Haskell i) Library code ii) Documentation iii) Unit tests iv) Write your own programs v) Phantom Phases How to extend the type checker 0. Folder Structure {#folder-structure} The folder structure of this artefact is as follows: . |--- README.html (Documentation of the artefact in HTML format) |--- README.pdf (Documentation of the artefact in PDF format) |--- documentation (auto-generated documention from code) | |--- index.html | |--- ... | |--- assets | |--- fonts | |--- pandoc.css | |--- submitted-version.pdf | |--- typechecker-oopl (Type checker) |--- stack.yaml |--- LICENSE-MIT |--- README.md |--- Setup.hs |--- package.yaml |--- src | |--- Applicative (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Backtrace (Section 4) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Final (Final type checker) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Initial (Section 2) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- MultiError (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomFunctors (Section 7) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomPhases (Another approach to Section 7, explained later) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Reader (Section 3) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Warning (Section 5) | |--- AST.hs | |--- Typechecker.hs | |--- stack.yaml |--- test | |--- Spec.hs | |--- typechecker-oopl.cabal The instructions are in README.html and README.pdf . The assets folder contains assets for the HTML version and the submitted paper. If you are reading the HTML version, the links to the paper direct you to the appropriate page. If you are using the PDF version, the links only point to the paper. The implementation can be found under the project folder named typechecker-oopl . All the code is documented and the auto-generated documentation can be found under the folder documentation . As per the paper, the type checker is (mostly) built incrementally, following the order specified in the paper: Initial ( Paper: Section 2 ) Reader ( Paper: Section 3 ) Backtrace ( Paper: Section 4 ) Warning ( Paper: Section 5 ) Multiple Errors or Applicative ( Paper: Section 6 ) PhantomFunctors ( Paper: Section 7 ) Final (The final version that aggregates all of the previous ones). As part of an intermediate step to Section 7 (Type State) , we have created a simplification of this section, which removes the abstraction over functors. This is less elegant but an intermediate step for readers who are still learning Haskell and prefer to take a smaller step before jumping into Section 7 . 1. Prerequisites {#prerequisites} The library is written in the Haskell programming language and has the following dependencies: GHC 8.6.3 stack Below you can find information on how to install these dependencies in OSX , Linux and Windows . We also provide instructions on how to download a ready-to-use virtual machine. Installing prerequisites on OSX {#setup-osx} Type the following command to install stack . curl -sSL https://get.haskellstack.org/ | sh To install GHC 8.6.3 and all the dependencies from the project, type: cd typechecker-oopl stack build If you need further assistance installing Haskell and stack , please click here . Installing prerequisites on Linux {#setup-linux} Type the following command to install stack . sudo apt-get update curl -sSL https://get.haskellstack.org/ | sh To install GHC 8.6.3 and all the dependencies from the project, type: cd typechecker-oopl stack build If you need further assistance installing Haskell and stack , please click here . Installing prerequisites on Windows (non-tested) {#setup-windows} Download the stack binary from here , and proceed with the normal installation process. If you need further assistance installing Haskell and stack , please click here . Using a provisioned Virtual Machine {#vm} This artefact contains a Virtual Machine (VM) named TypeChecker.ova . You can use your favorite virtualisation software. We have tested this VM using Virtual Box . After importing the VM, start and login to the VM with the following credentials: user: vagrant password: vagrant Upon login, a terminal will pop up to receive you. Please type the following command to go to the artefact folder: cd Desktop/TypeChecker If necessary, you can also open this documentation in the VM. Locate the folder TypeChecker in the Desktop , open it and open the file README.html . 2. Implementation in Haskell {#Implementation} This section contains the following information: the library code , documentation about the library, unit tests , how to write your own programs , and a new section on Phantom Phases , a smaller increment before diving into Section 7 . i) Library Code {#library-code} The library code can be found in the folder typechecker-oopl (where typechecker-oopl stands for type checker of an Object-Oriented Language): cd typechecker-oopl As per the paper, the type checker is built incrementally following (mostly) the order specified in the paper: Initial ( Paper: Section 2 ) Reader ( Paper: Section 3 ) Backtrace ( Paper: Section 4 ) Warning ( Paper: Section 5 ) Multiple Errors or Applicative ( Paper: Section 6 ) PhantomFunctors ( Paper: Section 7 ) Final (The final version that aggregates all of the previous ones). This is reflected in the structure of the type checker package. Under the src folder, there are folders for each of the incremental changes. (Read Deviations from the paper section to check for the differences between the paper and the implementation incremental ordering). |--- typechecker-oopl (Type checker) |--- stack.yaml |--- LICENSE-MIT |--- README.md |--- Setup.hs |--- package.yaml |--- src | |--- Applicative (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Backtrace (Section 4) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Final (Final type checker) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Initial (Section 2) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- MultiError (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomFunctors (Section 7) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomPhases (Another approach to Section 7, explained later) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Reader (Section 3) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Warning (Section 5) | |--- AST.hs | |--- Typechecker.hs | |--- stack.yaml |--- test | |--- Spec.hs | |--- typechecker-oopl.cabal All the incremental implementations from the paper matches the increments highlighed on a per-section basis.^[There are minor deviations, explained in Section: Deviation from the paper .] All the modules, Initial , Backtrace , etc. contain two files, AST.hs and Typechecker.hs . The file AST.hs contains the definition of the Abstract Syntax Tree (AST) of our language. Since our focus is on type checking, we assume that a parser generates the AST as per our definition. The Typechecker.hs module contains the main type checking algorithm, helper functions for type checking, as well as the definition of the TypecheckM monad -- used throughout the paper. We recommend the reader to visit section Documentation for checking the documentation as well as the source code, from the browser. More advanced readers can use an IDE to better read the code. Deviation from the paper {#deviation} We have tried to build the type checker as in the paper, in an incremental way. However, there are minor modifications. For example, the PhantomFunctor module ( Section 7 (Type State) ) is implemented without many of the previous features, such as warnings and backtraces. Since this is arguably the most advanced extension, we wanted to focus on the type state features alone. As argued in the paper though, the order in which we add the extensions is unimportant, and the Final module still contains all the extensions to the type checker, as explained in the paper. Since the extensions for supporting parametric polymorphism ( Section 8 ) and uniqueness types ( Section 10 ) require more significant changes to the language being type checked, this has not been implemented in this artefact. A brief description of how to extend the type checker with subtyping support ( Section 9 ) is included at the end of this document . ii) Documentation {#documentation} We have put emphasis on the code documentation, auto-generated in the folder: TypeChecker/documentation and the following folder in the VM: /home/vagrant/Desktop/TypeChecker/documentation (We refer the reader to the folder structure section in case of doubts). The following list links pdf sections with their implementation increments: Global Index 2. A Small Object-Oriented language -- Typechecker.hs and AST.hs 3. Refactoring: Removing Boilerplate -- Typechecker.hs and AST.hs 4. Extension: Support for backtraces -- Typechecker.hs and AST.hs 5. Extension: Addition of Warnings -- Typechecker.hs and AST.hs 6. Extension: Support Multiple Errors i) Approach 1. Typechecker.hs and AST.hs ii) Approach 2. Typechecker.hs and AST.hs 7. Refactoring: Type State Phases -- Typechecker.hs and AST.hs One can access the Haskell auto-generated documentation, by clicking in the top-level Source button (between Quick Jump and Contents ). (As an example, the reader can click on this link , which opens up the documentation for the warnings module, and try the clicking of the Source button). The documentation also links to its implementation on a per function basis (click the #Source link of any function). iii) Unit tests {#unit-tests} There is a single file that contains unit tests for all the increments, located in typechecker-oopl/test/Spec.hs . Upon execution of the unit test, the reader will observe how each increment improves the type checker. In the terminal, enter to the folder: cd typechecker-oopl Inside this terminal, run the tests typing:^[ stack test builds the modules and run the tests.] stack test You should see a long output, similar to: -- Possible recompilation of modules ****************************************** ** ** ** Simple compile test suite ** ** ** ****************************************** Welcome to the test suite. The type checker is going to run some tests and show the output according to new features added to the compiler. All versions of the type checker will type check the following program, which contains 3 errors: 1. The class ``Foo'' is not defined 2. The class ``Bar'' is not defined 3. The class variable ``x'' is not defined class C val f: Foo class D val g: Bar def m(): Int x ************************************************ 1. Initial Version. Showing a program with 3 errors: - type checker only catches one error - there is not support for backtrace Output: Unknown class 'Foo' ************************************************ ************************************************ 2. Refactoring to use the Reader monad -- no extensions. Showing a program with 3 errors: - type checker only catches one error - there is not support for backtrace Output: Unknown class 'Foo' ************************************************ ************************************************ 3. Add backtrace information. Showing a program with 3 errors: - type checker only catches one error - support for backtrace Output: *** Error during typechecking *** Unknown class 'Foo' In type 'Foo' In field 'val f : Foo' In class 'C' ... The reader can check how, at each increment, the type checker becomes more powerful. There are two exceptions: the refactoring of boiler plate (Section 2) and the type state of phases (Section 7). The former is a refactoring that does not add any new features; the latter can be tested by simply trying to write an AST in Haskell that does not match the expected phase, since it will be rejected statically by GHC. iv) Write your own programs {#write-your-own-programs} There are two ways to play with the library: [Test existing programs] [Write your own program] Before we discuss how to play with the library (write your own programs), we explain how to fire up a REPL. Then we will continue with how to test existing programs and how to write your own programs. Starting a REPL {#start-repl} Both of them involve running a REPL. To start a REPL, the terminal must be inside the folder typechecker-oopl . Then, type: stack ghci Once the REPL is ready, load any modules that you plan on using. For example, let's load the Warning module: :m Warning.Typechecker Warning.AST From now on, you can use all the functions defined in the module Warning , i.e., Warning.Typechecker and Warning.AST . Test existing programs To test existing programs, please read on how to start a REPL . Each of the increments contain basic programs that simply define an AST node. For example, lets assume that the REPL has loaded the module Warning . Then, we can test existing programs such as testClass1 , testClass2 , and testClass3 by fully qualifying them as follows:^[By fully qualifying existing programs we prevent rebinding of existing programs from users, i.e., users naming their programs the same as the examples which could end up with programs mixing ASTs from different modules.] :m Warning.Typechecker Warning.AST let program = Program [Warning.Typechecker.testClass1] We bind a Program AST node Warning.Typechecker.testClass1 to the program variable (the implementation of testClass1 is defined here ). To type check program , type: tcProgram program for which we get an error (which we expected, since class Foo is not defined): Left *** Error during typechecking *** Unknown class 'Foo' In type 'Foo' In field 'val f : Foo' In class 'C' A more complex example can be simply defined as: let program = Program [testClass2, testClass1] To type check, type: tcProgram program which throws the following error: Left *** Error during typechecking *** Unknown class 'Bar' In type 'Bar' In field 'val g : Bar' In class 'D' However, we may want to see all the errors. To check this fact, we are going to remove existing bindings by reloading the project modules, load the MultiError module, and rebind the program variable to the AST of the MultiError module, as follows: :reload :m MultiError.Typechecker MultiError.AST let program = Program [MultiError.Typechecker.testClass2, MultiError.Typechecker.testClass1] tcProgram program which throws now 3 type checking errors: Left *** Error during typechecking *** Unknown class 'Bar' In type 'Bar' In field 'val g : Bar' In class 'D' Unbound variable 'x' In expression x In method 'm' In class 'D' Unknown class 'Foo' In type 'Foo' In field 'val f : Foo' In class 'C' These examples are easy to understand. The reader can write more complex examples, while being careful of creating a valid AST node (which a parser would usually generate). Write your own program To create your own programs, one needs to import the AST module of the increment that should be tested. There are examples of AST programs in each of the Typechecker.hs module that can serve as inspiration, and most if not all of them are almost the same. ::: warning :::::: Information: Convenience copy-and-paste If the reader wants to simply copy-and-paste code from the snippets to the REPL, then use this multiline notation: :{ <write your multiline example> :} :::::::::::::::::::::::: For example, lets look at the MultiError/AST.hs module ( here ) and create a class definition: :reload :m MultiError.Typechecker MultiError.AST -- :{ and :} are for multiline examples that -- can be copy-pasted directly from the documentation -- into the REPL :{ let cls = ClassDef {cname = \"D\" ,fields = [FieldDef {fmod = Val, fname = \"g\", ftype = ClassType \"Bar\"}] ,methods = [MethodDef {mname = \"m\", mparams = [], mtype = IntType, mbody = VarAccess Nothing \"x\"}]} :} To type check the program, wrap it in a Program AST node and call the main type checking function: let program = Program [cls] tcProgram program Below we show helper functions, that the reader can copy-paste, and we build 5 examples of ASTs, where one of them also updates the compiler to throw multiple exceptions when doing binary operations, and show their equivalence in pseudo-code: (Do not forget to check tips on how to avoid mixing ASTs ) Helper Functions 1. Class with unbound variable 2. Class with two methods with unbound variable and unknown field errors 3. Updating the compiler to throw multiple errors in binary operations 4. Creating a new instance of a class that does not exist 5. Testing PhantomFunctors module Helper Functions {#helper-func} These helper functions are merely shorthand functions for not writing specific AST nodes. We believe these could be useful for less well-versed Haskell developers. We write also the type signature of these functions, so that the reader can look in the according AST from the module at test.^[We have used the String type, instead of Name , because the implementation is just an alias and think that it could be more helpful for the reader.] -- Class Factory: classFactory :: String -> [FieldDef] -> [MethodDef] -> ClassDef classFactory name fields methods = ClassDef name fields methods -- Field factory: fieldFactory :: Mod -> Name -> Type -> FieldDef fieldFactory modif name ty = FieldDef name ty modif -- Method factory methodFactory :: String -> [Param] -> Type -> Expr -> MethodDef methodFactory name params ty body = MethodDef name params ty body -- Parameter factory paramFact :: String -> Type -> Param paramFact name ty = Param name ty -- Field Access fieldAccess :: Expr -> String -> FieldAccess fieldAccess expr name = FieldAccess Nothing expr name -- Variable access varAccess :: String -> VarAccess varAccess nam = VarAccess Nothing nam -- Access to `this`. thisAccess :: VarAccess thisAccess = VarAccess Nothing thisName -- Binary operation binaryOp :: Op -> Expr -> Expr -> BinOp binaryOp op lhs rhs = BinOp Nothing op lhs rhs The reader should not copy these functions in the REPL, since the 5 following examples copy-paste the helper functions definitions^[The helper function definitions in some cases do not actually match the expected types, especially in the case of PhantomFunctors (and therefore also Final ). However, we provide a specific example for this module .] 1. Class with unbound variable {#ex1} This example tries to perform the sum on a variable ( y ) that has not been declared: class Object val x: Int -- immutable field def foo(): int this.x == y end end The following functions create the corresponding AST, which we test on the e.g., Backtrace module (feel free to copy-paste this in the REPL): :reload :m Backtrace.Typechecker Backtrace.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 1 above: paramsExample = [] bodyExample = binaryOp Add (fieldAccess thisAccess \"x\") (varAccess \"y\") methodsExample = [methodFactory \"foo\" paramsExample IntType bodyExample] fieldsExample = [fieldFactory Val \"x\" IntType] classesExample = classFactory \"Object\" fieldsExample methodsExample programExample1 = Program [classesExample] -- type checking of the program tcProgram programExample1 which outputs: Left *** Error during typechecking *** Unbound variable 'y' In expression y In expression this.x + y In method 'foo' In class 'Object' 2. Class with two methods with unbound variable and unknown field errors {#ex2} This example declares a class and two methods: foo and bar . The methods try to access an unbound variable and an unknown field. class Object def foo(): int this.x end def bar(): bool y end end As before, we the code below reloads the module, loads the Backtrace module, (re)defines the helper functions in the loaded module, and encodes the AST: :reload :m Backtrace.Typechecker Backtrace.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 2 above: paramsExample2 = [] methodsExample21 = methodFactory \"foo\" paramsExample2 IntType (fieldAccess thisAccess \"x\") methodsExample22 = methodFactory \"bar\" paramsExample2 IntType (varAccess \"y\") classesExample2 = classFactory \"Object\" [] [methodsExample21, methodsExample22] programExample2 = Program [classesExample2] -- type checking of the program tcProgram programExample2 The error is: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In method 'foo' In class 'Object' However, we can observe how there are actually two errors. To get the compiler to report all the errors, we can test the output of loading the MultiError module: :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 2 above: paramsExample2 = [] methodsExample21 = methodFactory \"foo\" paramsExample2 IntType (fieldAccess thisAccess \"x\") methodsExample22 = methodFactory \"bar\" paramsExample2 IntType (varAccess \"y\") classesExample2 = classFactory \"Object\" [] [methodsExample21, methodsExample22] programExample2 = Program [classesExample2] -- type checking of the program tcProgram programExample2 which now outputs both errors: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In method 'foo' In class 'Object' Unbound variable 'y' In expression y In method 'bar' In class 'Object' 3. Updating the compiler to throw multiple errors in binary operations {#ex3} In the current type checker, we only throw multiple exception in some cases. The reader can play with the code to extend it to places where one would expect to observe multiple errors. Let us handle throwing multiple errors when doing a binary operation, such as the following one: class Object def foo(): int this.x + y end end We would expect two errors, one for the unbound field this.x and one for the unbound variable y . Currently, we only throw one exception even when we load the MultiError module (please copy-paste the code below in the REPL): :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 3 above: paramsExample3 = [] bodyExample3 = binaryOp Add (fieldAccess thisAccess \"x\") (varAccess \"y\") methodsExample3 = [methodFactory \"foo\" paramsExample3 BoolType bodyExample3] classesExample3 = classFactory \"Object\" [] methodsExample3 programExample3 = Program [classesExample3] -- type checking of the program tcProgram programExample3 but the output only shows one error: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In expression this.x + y In method 'foo' In class 'Object' Lets update the type checking function on binary operations to handle this case. In the module MultiError.Typechecker.hs [ here ], we have the following type checking implementation for BinOp : doTypecheck e@(BinOp {op, lhs, rhs}) = do lhs' <- hasType lhs IntType rhs' <- hasType rhs IntType return $ setType IntType e{lhs = lhs' ,rhs = rhs'} Adding multiple errors is as simple as using the forking combinator as per the paper ( Sec. 6 ). The type signature for <&> is: (<&>) :: (Semigroup e, MonadError e m) => m a -> m b -> m (a, b) Since the function hasType ( hasType :: Expr -> Type -> TypecheckM Expr ) returns a monad, we can just apply two monadic actions (i.e., the call to hasType to the left-hand side and right-hand side) and aggregate the errors as follows: doTypecheck e@(BinOp {op, lhs, rhs}) = do (lhs',rhs') <- hasType lhs IntType <&> hasType rhs IntType return $ setType IntType e{lhs = lhs' ,rhs = rhs'} If we reload the module and re-run the example: :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 3 above: paramsExample3 = [] bodyExample3 = binaryOp Add (fieldAccess thisAccess \"x\") (varAccess \"y\") methodsExample3 = [methodFactory \"foo\" paramsExample3 BoolType bodyExample3] classesExample3 = classFactory \"Object\" [] methodsExample3 programExample3 = Program [classesExample3] -- type checking of the program tcProgram programExample3 the type checker now captures multiple errors even in this case: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In expression this.x + y In method 'foo' In class 'Object' Unbound variable 'y' In expression y In expression this.x + y In method 'foo' In class 'Object' 4. Creating a new instance of a class that does not exist {#ex4} This example shows how to create a new instance of a class inside a method, which requires the use of a Let expression. In the surface language we do not expect developers to use Let expressions directly, and the parser would actually generate these bindings. The code below instantiates a non-existing class: class Object def foo(): Object let x = new C in x end end The code below reloads the module, (re)defines helper functions in the loaded module, and encodes the AST of the program above. :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 4 above: paramsExample4 = [] bodyExample4 = Let Nothing \"x\" (New Nothing (ClassType \"D\")) (VarAccess Nothing \"x\") methodsExample4 = [methodFactory \"foo\" paramsExample4 (ClassType \"Object\") bodyExample4] classesExample4 = classFactory \"Object\" [] methodsExample4 programExample4 = Program [classesExample4] -- type checking of the program tcProgram programExample4 The expected error is: Left *** Error during typechecking *** Unknown class 'D' In type 'D' In expression new D In expression let x = new D in x In method 'foo' In class 'Object' The reader can fix the current issue by creating a class that contains no fields nor methods, and named D . class D end class Object def foo(): Object let x = new D in x end end Below we reload the module and show the resulting AST: :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 4 above: paramsExample4 = [] bodyExample4 = Let Nothing \"x\" (New Nothing (ClassType \"D\")) (VarAccess Nothing \"x\") methodsExample4 = [methodFactory \"foo\" paramsExample4 (ClassType \"Object\") bodyExample4] classesExample4 = classFactory \"Object\" [] methodsExample4 programExample4 = Program [classesExample4, classFactory \"D\" [] []] -- type checking of the program tcProgram programExample4 The expected error is that the returned type of the method differs from the expected returned type, Object != D : Left *** Error during typechecking *** Type 'D' does not match expected type 'Object' In method 'foo' In class 'Object' 5. Testing PhantomFunctors and Final module {#ex5} Testing the PhantomFunctors (and Final modules) requires a bit more work because we do no get the right algebraic data type in its expected 'Parsed kind. Reusing example 4 , which is the following program: class Object def foo(): Object let x = new C in x end end We show below the encoding of the AST, which requires the extension -XDataKinds , and the explicit type signatures that are given to the helper functions: :reload :set -XDataKinds :m Data.Proxy PhantomFunctors.Typechecker PhantomFunctors.AST :{ classFactory :: Name -> [FieldDef 'Parsed] -> [MethodDef 'Parsed] -> ClassDef 'Parsed classFactory name fields methods = ClassDef name fields methods fieldFactory :: Mod -> Name -> Type 'Parsed -> FieldDef 'Parsed fieldFactory modif name ty = FieldDef name ty modif methodFactory :: Name -> [Param 'Parsed] -> Type 'Parsed -> Expr 'Parsed -> MethodDef 'Parsed methodFactory name params ty body = MethodDef name params ty body paramFact :: Name -> Type 'Parsed -> Param 'Parsed paramFact name ty = Param name ty fieldAccess :: Expr 'Parsed -> Name -> Expr 'Parsed fieldAccess expr name = FieldAccess Proxy expr name varAccess :: Name -> Expr 'Parsed varAccess nam = VarAccess Proxy nam thisAccess :: Expr 'Parsed thisAccess = VarAccess Proxy thisName binaryOp :: Op -> Expr 'Parsed -> Expr 'Parsed -> Expr 'Parsed binaryOp op lhs rhs = BinOp Proxy op lhs rhs -- Actual encoding of the example 5 above: paramsExample5 = [] bodyExample5 = Let Proxy \"x\" (New Proxy (ClassType \"D\")) (varAccess \"x\") methodsExample5 = [methodFactory \"foo\" paramsExample5 (ClassType \"Object\") bodyExample5] classesExample5 = classFactory \"Object\" [] methodsExample5 programExample5 = Program [classesExample5] :} tcProgram programExample5 which outputs:^[There is no backtrace/stack trace because this module does not include the additions from the Backtrace module.] Left Unknown class 'D' ::: warning :::::: Information: how to avoid mixing ASTs {#mixin-ast} Upon loading a module, such as: :m MultiError.Typechecker MultiError.AST one creates programs that are tied to the MultiError.AST nodes. It is possible to mistakenly create new definitions that refer to different AST s, which will only fail upon trying to mix them. We recommend to remove all existing bindings when moving to a new module, and use the up-down arrows of the keyboard (in the REPL) to loop through entered definitions and reuse them (alternatively, one can have a file to keep these). For example: :reload :m Warning.Typechecker Warning.AST let program = Program [testClass1] -- User-defined function testClass1 = ClassDef {cname = \"C\",fields = [FieldDef {fmod = Val, fname = \"f\", ftype = ClassType \"Foo\"}],methods = []} -- add `testClass1` into the `Program` AST node. let program = Program [testClass1] -- Testing the function in the `Warning` module. tcProgram program -- some output of the errors. -- ... -- User would like to test output of a different -- type checker. The reader should reload project -- when moving to another module, which -- removes existing bindings. :reload :m MultiError.Typechecker MultiError.AST -- use up and down arrows until one finds -- the existing definition to re-test, here -- the `testClass1` testClass1 = ClassDef {cname = \"C\",fields = [FieldDef {fmod = Val, fname = \"f\", ftype = ClassType \"Foo\"}],methods = []} -- add `testClass1` into the `Program` AST node. let program = Program [testClass1] -- Test type checker, errors, warnigns, etc. tcProgram program :::::::::::::::::::::::: v) Phantom Phases {#phantom-phases} This section can be thought as an intermediate step before Section 7. Refactoring: Type State Phases , and has been written as such. Its implementation is in typechecker-oopl/src/PhantomPhases , under Typechecker.hs and AST.hs 6.5. Refactoring: Phantom Phases It is really simple to introduce bugs in the compiler. For example, can you spot the error in the following function? instance Typecheckable Expr where typecheck e@(FunctionCall {target, args}) = do target' <- typecheck target let targetType = getType target unless (isArrowType targetType) $ throwError $ NonArrowTypeError targetType let paramTypes = tparams targetType resultType = tresult targetType args' <- zipWithM hasType args paramTypes return $ setType resultType e {target = target', args = args'} The error is in the line let targetType = getType target which tries to get the type of the current function from a node named target . However, target has not been type checked and does not have any typing information. Instead, the line should refer to the already type checked node, target' , which has been decorated with the typing information. A similar kind of bug is forgetting to decorate an expression with its type, which could cause errors in later stages of the compiler. In this section, we propose one solution to statically avoid these kind of bugs. The main idea is to use the Haskell type system to let the AST nodes track whether they have been type checked or not, so that we can prevent the use of undecorated AST nodes where we do not expect them. This will be implemented using phantom types.^[Matthew Fluet and Riccardo Pucella. 2006. Phantom types and sub-typing. J. Funct. Program. 16, 6 (2006). https://doi.org/10.1017/S0956796806006046] A full compiler goes through multiple phases. The type checker receives an undecorated AST node from the parsing phase, which then gets decorated during the type checking phase. Let us therefore reify the current phase in a data type: data Phase = Parsed | Checked Since we are aiming to use Parsed and Checked as phantom type parameters, the data type Phase needs to be lifted to the kind level. This can be done with the GHC extension DataKinds . With the extension KindSignatures , we can update the AST data types to take a phantom type of kind Phase : data Type (p :: Phase) = ClassType Name | IntType | BoolType | Arrow {tparams :: [Type p] ,tresult :: Type p} | UnitType deriving (Eq) newtype Program (p :: Phase) = Program [ClassDef p] deriving (Show) data ClassDef (p :: Phase) = ClassDef {cname :: Name ,fields :: [FieldDef p] ,methods :: [MethodDef p] } data Expr (p :: Phase) = BoolLit {etype :: Maybe (Type p) ,bval :: Bool} | Lambda {etype :: Maybe (Type p) ,params :: [Param p] ,body :: Expr p} | FieldAccess {etype :: Maybe (Type p) ,target :: Expr p ,name :: Name} | MethodCall {etype :: Maybe (Type p) ,target :: Expr p ,name :: Name ,args :: [Expr p]} | ... Note that a class definition is only considered Checked if all its fields and classes are Checked , and similarly for an expression and its subexpressions. Intuitively, the type of the type checking function for an expression is now going to be Expr 'Parsed -> Expr 'Checked , ensuring that we do not forget to check any expressions. Similarly, we change the type of a function like getType to Expr 'Checked -> Type 'Checked , ensuring that we only ever try to get the type of a decorated AST node. The entry point to the type checker must be updated, since it takes an undecorated program (with phantom type Parsed ) and returns either an error or a decorated program (with phantom type Checked ). An important change is that the environment used for type checking must only contain well-formed types. For example, if we use the environment to look up the type of a field, this field must not have an undefined type. Because of this, generating the environment can now fail if it finds an undefined type. Hence, we now require the use of the exception monad when building the environment: tcProgram :: Program 'Parsed -> Either TCError (Program 'Checked) tcProgram p = do env <- runExcept $ runReaderT (genEnv p) (generatePreEnv p) runExcept $ runReaderT (doTypecheck p) env Note that due to a chicken-and-egg problem, the environment Env can no longer contain full class definitions: in order to run the type checker we need a well-formed environment, but in order to get an environment containing well-formed classes we would need to run the type checker! Instead we change the environment to use special entries which only contain the (well-formed) types of classes, methods and fields. When building the environment, we use a simpler kind of environment which we dub a pre-environment which simply contains a list of all the valid class names, allowing us to check the well-formedness of types. We call the process of checking the types used by classes, fields and methods pre-checking , and use a type class scheme similar to the main type checker: class Precheckable a b where precheck :: a -> TypecheckM b Note that we reuse our type checking monad from before, including any of the previous extensions we might have added. For each kind of AST node a , we define an instance Precheckable a b which returns an entry of type b that can be used by the environment being generated. For example, pre-checking a class generates a ClassEntry , containing the (well-formed) types of all fields and methods: data MethodEntry = MethodEntry {meparams :: [Param 'Checked] ,metype :: Type 'Checked} data FieldEntry = FieldEntry {femod :: Mod ,fetype :: Type 'Checked} data ClassEntry = ClassEntry {cefields :: Map Name FieldEntry ,cemethods :: Map Name MethodEntry} data Env = PreEnv {classes :: [Name]} | Env {ctable :: Map Name ClassEntry ,vartable :: Map Name (Type 'Checked)} genEnv :: Program 'Parsed -> TypecheckM Env genEnv (Program classes) = do classEntries <- mapM precheck classes let cnames = map cname classes duplicates = cnames \\\\ nub cnames unless (null duplicates) $ throwError $ DuplicateClassError (head duplicates) return $ Env {vartable = Map.empty ,ctable = Map.fromList $ zip cnames classEntries} instance Precheckable (ClassDef 'Parsed) ClassEntry where precheck ClassDef {fields, methods} = do fields' <- mapM precheck fields methods' <- mapM precheck methods return ClassEntry {cefields = Map.fromList $ zip (map fname fields) fields' ,cemethods = Map.fromList $ zip (map mname methods) methods'} After pre-checking, we have a well-formed environment that we can use to type check the program just as before. The Typecheckable type class changes into: class Typecheckable a where typecheck :: a 'Parsed -> TypecheckM (a 'Checked) Thanks to phantom types, the Haskell compiler now helps us ensure that our type checking functions indeed return AST nodes which have been checked, and will statically notify us about the usage of undecorated AST nodes when one expects them to have typing information. Once more, the original implementation of the type checker did not change notably , we just added phantom types to some definitions and changed how we generate environments. 3. How to extend the type checker {#extend-type-checker} Here we document an overview on how to extend the type checker with subtyping, closely following the explanations of the paper ( Section 9 ). The first thing to consider is whether we need a new AST node to represent traits, which we do. Hence, we declare the TraitDecl node as well as their new dependencies ( Requirement AST node): data TraitDecl = Trait { tname :: Type, treqs :: [Requirement], tmethods :: [MethodDecl] } deriving (Show) data Requirement = RequiredField { rfield :: FieldDecl } | RequiredMethod { rmethods :: MethodDecl } deriving(Show) The TraitDecl has a field for the name of the trait, a list of requirements expected from the trait, and method declarations. The requirements could be imposed on fields ( RequiredField ) or methods ( RequiredMethod ). Now the parser can read a trait declaration and produce a TraitDecl AST node. The next thing to do is to extend the environment, so that the type checker can statically check subtyping properties between classes and traits. To do this, we extend the environment as follows (highlighted in blue in HTML): #cb36-2 { background: lightblue } data Env = Env {ctable :: Map Name ClassDef ,traittable :: Map Name TraitDecl ,vartable :: Map Name Type ,typeParameters :: [Type] ,bt :: Backtrace} After this change, we can type check a class and check that the required fields and methods of its trait are present, as per the following outline in the doTypecheck function: doTypecheck c@(Class {cname, cfields, cmethods, ctraits}) = do local addTypeVars $ mapM_ typecheck ctraits mapM_ isTraitType ctraits mapM_ (meetRequiredFields cfields) ctraits meetRequiredMethods cmethods ctraits ensureNoMethodConflict cmethods ctraits ... The following lines checks that traits are well-formed: local addTypeVars $ mapM_ typecheck ctraits mapM_ isTraitType ctraits After that, we check that the requirements of the traits apply to the current class, ensuring that there are no method conflicts (e.g.). As an example, this could be written as follows. mapM_ (meetRequiredFields cfields) ctraits meetRequiredMethods cmethods ctraits ensureNoMethodConflict cmethods ctraits","title":"Relatorio"},{"location":"Modelos/Relatorio/relatorio/#table-of-contents","text":"Folder Structure Prerequisites i) Installing prerequisites on OSX ii) Installing prerequisites on Linux iii) Installing prerequisites on Windows iv) Using a provisioned Virtual Machine Implementation in Haskell i) Library code ii) Documentation iii) Unit tests iv) Write your own programs v) Phantom Phases How to extend the type checker","title":"Table of Contents:"},{"location":"Modelos/Relatorio/relatorio/#0-folder-structure-folder-structure","text":"The folder structure of this artefact is as follows: . |--- README.html (Documentation of the artefact in HTML format) |--- README.pdf (Documentation of the artefact in PDF format) |--- documentation (auto-generated documention from code) | |--- index.html | |--- ... | |--- assets | |--- fonts | |--- pandoc.css | |--- submitted-version.pdf | |--- typechecker-oopl (Type checker) |--- stack.yaml |--- LICENSE-MIT |--- README.md |--- Setup.hs |--- package.yaml |--- src | |--- Applicative (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Backtrace (Section 4) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Final (Final type checker) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Initial (Section 2) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- MultiError (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomFunctors (Section 7) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomPhases (Another approach to Section 7, explained later) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Reader (Section 3) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Warning (Section 5) | |--- AST.hs | |--- Typechecker.hs | |--- stack.yaml |--- test | |--- Spec.hs | |--- typechecker-oopl.cabal The instructions are in README.html and README.pdf . The assets folder contains assets for the HTML version and the submitted paper. If you are reading the HTML version, the links to the paper direct you to the appropriate page. If you are using the PDF version, the links only point to the paper. The implementation can be found under the project folder named typechecker-oopl . All the code is documented and the auto-generated documentation can be found under the folder documentation . As per the paper, the type checker is (mostly) built incrementally, following the order specified in the paper: Initial ( Paper: Section 2 ) Reader ( Paper: Section 3 ) Backtrace ( Paper: Section 4 ) Warning ( Paper: Section 5 ) Multiple Errors or Applicative ( Paper: Section 6 ) PhantomFunctors ( Paper: Section 7 ) Final (The final version that aggregates all of the previous ones). As part of an intermediate step to Section 7 (Type State) , we have created a simplification of this section, which removes the abstraction over functors. This is less elegant but an intermediate step for readers who are still learning Haskell and prefer to take a smaller step before jumping into Section 7 .","title":"0. Folder Structure {#folder-structure}"},{"location":"Modelos/Relatorio/relatorio/#1-prerequisites-prerequisites","text":"The library is written in the Haskell programming language and has the following dependencies: GHC 8.6.3 stack Below you can find information on how to install these dependencies in OSX , Linux and Windows . We also provide instructions on how to download a ready-to-use virtual machine.","title":"1. Prerequisites {#prerequisites}"},{"location":"Modelos/Relatorio/relatorio/#installing-prerequisites-on-osx-setup-osx","text":"Type the following command to install stack . curl -sSL https://get.haskellstack.org/ | sh To install GHC 8.6.3 and all the dependencies from the project, type: cd typechecker-oopl stack build If you need further assistance installing Haskell and stack , please click here .","title":"Installing prerequisites on OSX {#setup-osx}"},{"location":"Modelos/Relatorio/relatorio/#installing-prerequisites-on-linux-setup-linux","text":"Type the following command to install stack . sudo apt-get update curl -sSL https://get.haskellstack.org/ | sh To install GHC 8.6.3 and all the dependencies from the project, type: cd typechecker-oopl stack build If you need further assistance installing Haskell and stack , please click here .","title":"Installing prerequisites on Linux {#setup-linux}"},{"location":"Modelos/Relatorio/relatorio/#installing-prerequisites-on-windows-non-tested-setup-windows","text":"Download the stack binary from here , and proceed with the normal installation process. If you need further assistance installing Haskell and stack , please click here .","title":"Installing prerequisites on Windows (non-tested) {#setup-windows}"},{"location":"Modelos/Relatorio/relatorio/#using-a-provisioned-virtual-machine-vm","text":"This artefact contains a Virtual Machine (VM) named TypeChecker.ova . You can use your favorite virtualisation software. We have tested this VM using Virtual Box . After importing the VM, start and login to the VM with the following credentials: user: vagrant password: vagrant Upon login, a terminal will pop up to receive you. Please type the following command to go to the artefact folder: cd Desktop/TypeChecker If necessary, you can also open this documentation in the VM. Locate the folder TypeChecker in the Desktop , open it and open the file README.html .","title":"Using a provisioned Virtual Machine {#vm}"},{"location":"Modelos/Relatorio/relatorio/#2-implementation-in-haskell-implementation","text":"This section contains the following information: the library code , documentation about the library, unit tests , how to write your own programs , and a new section on Phantom Phases , a smaller increment before diving into Section 7 .","title":"2. Implementation in Haskell {#Implementation}"},{"location":"Modelos/Relatorio/relatorio/#i-library-code-library-code","text":"The library code can be found in the folder typechecker-oopl (where typechecker-oopl stands for type checker of an Object-Oriented Language): cd typechecker-oopl As per the paper, the type checker is built incrementally following (mostly) the order specified in the paper: Initial ( Paper: Section 2 ) Reader ( Paper: Section 3 ) Backtrace ( Paper: Section 4 ) Warning ( Paper: Section 5 ) Multiple Errors or Applicative ( Paper: Section 6 ) PhantomFunctors ( Paper: Section 7 ) Final (The final version that aggregates all of the previous ones). This is reflected in the structure of the type checker package. Under the src folder, there are folders for each of the incremental changes. (Read Deviations from the paper section to check for the differences between the paper and the implementation incremental ordering). |--- typechecker-oopl (Type checker) |--- stack.yaml |--- LICENSE-MIT |--- README.md |--- Setup.hs |--- package.yaml |--- src | |--- Applicative (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Backtrace (Section 4) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Final (Final type checker) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Initial (Section 2) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- MultiError (Section 6) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomFunctors (Section 7) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- PhantomPhases (Another approach to Section 7, explained later) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Reader (Section 3) | | |--- AST.hs | | |--- Typechecker.hs | | | |--- Warning (Section 5) | |--- AST.hs | |--- Typechecker.hs | |--- stack.yaml |--- test | |--- Spec.hs | |--- typechecker-oopl.cabal All the incremental implementations from the paper matches the increments highlighed on a per-section basis.^[There are minor deviations, explained in Section: Deviation from the paper .] All the modules, Initial , Backtrace , etc. contain two files, AST.hs and Typechecker.hs . The file AST.hs contains the definition of the Abstract Syntax Tree (AST) of our language. Since our focus is on type checking, we assume that a parser generates the AST as per our definition. The Typechecker.hs module contains the main type checking algorithm, helper functions for type checking, as well as the definition of the TypecheckM monad -- used throughout the paper. We recommend the reader to visit section Documentation for checking the documentation as well as the source code, from the browser. More advanced readers can use an IDE to better read the code.","title":"i) Library Code {#library-code}"},{"location":"Modelos/Relatorio/relatorio/#deviation-from-the-paper-deviation","text":"We have tried to build the type checker as in the paper, in an incremental way. However, there are minor modifications. For example, the PhantomFunctor module ( Section 7 (Type State) ) is implemented without many of the previous features, such as warnings and backtraces. Since this is arguably the most advanced extension, we wanted to focus on the type state features alone. As argued in the paper though, the order in which we add the extensions is unimportant, and the Final module still contains all the extensions to the type checker, as explained in the paper. Since the extensions for supporting parametric polymorphism ( Section 8 ) and uniqueness types ( Section 10 ) require more significant changes to the language being type checked, this has not been implemented in this artefact. A brief description of how to extend the type checker with subtyping support ( Section 9 ) is included at the end of this document .","title":"Deviation from the paper {#deviation}"},{"location":"Modelos/Relatorio/relatorio/#ii-documentation-documentation","text":"We have put emphasis on the code documentation, auto-generated in the folder: TypeChecker/documentation and the following folder in the VM: /home/vagrant/Desktop/TypeChecker/documentation (We refer the reader to the folder structure section in case of doubts). The following list links pdf sections with their implementation increments: Global Index 2. A Small Object-Oriented language -- Typechecker.hs and AST.hs 3. Refactoring: Removing Boilerplate -- Typechecker.hs and AST.hs 4. Extension: Support for backtraces -- Typechecker.hs and AST.hs 5. Extension: Addition of Warnings -- Typechecker.hs and AST.hs 6. Extension: Support Multiple Errors i) Approach 1. Typechecker.hs and AST.hs ii) Approach 2. Typechecker.hs and AST.hs 7. Refactoring: Type State Phases -- Typechecker.hs and AST.hs One can access the Haskell auto-generated documentation, by clicking in the top-level Source button (between Quick Jump and Contents ). (As an example, the reader can click on this link , which opens up the documentation for the warnings module, and try the clicking of the Source button). The documentation also links to its implementation on a per function basis (click the #Source link of any function).","title":"ii) Documentation {#documentation}"},{"location":"Modelos/Relatorio/relatorio/#iii-unit-tests-unit-tests","text":"There is a single file that contains unit tests for all the increments, located in typechecker-oopl/test/Spec.hs . Upon execution of the unit test, the reader will observe how each increment improves the type checker. In the terminal, enter to the folder: cd typechecker-oopl Inside this terminal, run the tests typing:^[ stack test builds the modules and run the tests.] stack test You should see a long output, similar to: -- Possible recompilation of modules ****************************************** ** ** ** Simple compile test suite ** ** ** ****************************************** Welcome to the test suite. The type checker is going to run some tests and show the output according to new features added to the compiler. All versions of the type checker will type check the following program, which contains 3 errors: 1. The class ``Foo'' is not defined 2. The class ``Bar'' is not defined 3. The class variable ``x'' is not defined class C val f: Foo class D val g: Bar def m(): Int x ************************************************ 1. Initial Version. Showing a program with 3 errors: - type checker only catches one error - there is not support for backtrace Output: Unknown class 'Foo' ************************************************ ************************************************ 2. Refactoring to use the Reader monad -- no extensions. Showing a program with 3 errors: - type checker only catches one error - there is not support for backtrace Output: Unknown class 'Foo' ************************************************ ************************************************ 3. Add backtrace information. Showing a program with 3 errors: - type checker only catches one error - support for backtrace Output: *** Error during typechecking *** Unknown class 'Foo' In type 'Foo' In field 'val f : Foo' In class 'C' ... The reader can check how, at each increment, the type checker becomes more powerful. There are two exceptions: the refactoring of boiler plate (Section 2) and the type state of phases (Section 7). The former is a refactoring that does not add any new features; the latter can be tested by simply trying to write an AST in Haskell that does not match the expected phase, since it will be rejected statically by GHC.","title":"iii) Unit tests {#unit-tests}"},{"location":"Modelos/Relatorio/relatorio/#iv-write-your-own-programs-write-your-own-programs","text":"There are two ways to play with the library: [Test existing programs] [Write your own program] Before we discuss how to play with the library (write your own programs), we explain how to fire up a REPL. Then we will continue with how to test existing programs and how to write your own programs.","title":"iv) Write your own programs {#write-your-own-programs}"},{"location":"Modelos/Relatorio/relatorio/#starting-a-repl-start-repl","text":"Both of them involve running a REPL. To start a REPL, the terminal must be inside the folder typechecker-oopl . Then, type: stack ghci Once the REPL is ready, load any modules that you plan on using. For example, let's load the Warning module: :m Warning.Typechecker Warning.AST From now on, you can use all the functions defined in the module Warning , i.e., Warning.Typechecker and Warning.AST .","title":"Starting a REPL {#start-repl}"},{"location":"Modelos/Relatorio/relatorio/#test-existing-programs","text":"To test existing programs, please read on how to start a REPL . Each of the increments contain basic programs that simply define an AST node. For example, lets assume that the REPL has loaded the module Warning . Then, we can test existing programs such as testClass1 , testClass2 , and testClass3 by fully qualifying them as follows:^[By fully qualifying existing programs we prevent rebinding of existing programs from users, i.e., users naming their programs the same as the examples which could end up with programs mixing ASTs from different modules.] :m Warning.Typechecker Warning.AST let program = Program [Warning.Typechecker.testClass1] We bind a Program AST node Warning.Typechecker.testClass1 to the program variable (the implementation of testClass1 is defined here ). To type check program , type: tcProgram program for which we get an error (which we expected, since class Foo is not defined): Left *** Error during typechecking *** Unknown class 'Foo' In type 'Foo' In field 'val f : Foo' In class 'C' A more complex example can be simply defined as: let program = Program [testClass2, testClass1] To type check, type: tcProgram program which throws the following error: Left *** Error during typechecking *** Unknown class 'Bar' In type 'Bar' In field 'val g : Bar' In class 'D' However, we may want to see all the errors. To check this fact, we are going to remove existing bindings by reloading the project modules, load the MultiError module, and rebind the program variable to the AST of the MultiError module, as follows: :reload :m MultiError.Typechecker MultiError.AST let program = Program [MultiError.Typechecker.testClass2, MultiError.Typechecker.testClass1] tcProgram program which throws now 3 type checking errors: Left *** Error during typechecking *** Unknown class 'Bar' In type 'Bar' In field 'val g : Bar' In class 'D' Unbound variable 'x' In expression x In method 'm' In class 'D' Unknown class 'Foo' In type 'Foo' In field 'val f : Foo' In class 'C' These examples are easy to understand. The reader can write more complex examples, while being careful of creating a valid AST node (which a parser would usually generate).","title":"Test existing programs"},{"location":"Modelos/Relatorio/relatorio/#write-your-own-program","text":"To create your own programs, one needs to import the AST module of the increment that should be tested. There are examples of AST programs in each of the Typechecker.hs module that can serve as inspiration, and most if not all of them are almost the same. ::: warning :::::: Information: Convenience copy-and-paste If the reader wants to simply copy-and-paste code from the snippets to the REPL, then use this multiline notation: :{ <write your multiline example> :} :::::::::::::::::::::::: For example, lets look at the MultiError/AST.hs module ( here ) and create a class definition: :reload :m MultiError.Typechecker MultiError.AST -- :{ and :} are for multiline examples that -- can be copy-pasted directly from the documentation -- into the REPL :{ let cls = ClassDef {cname = \"D\" ,fields = [FieldDef {fmod = Val, fname = \"g\", ftype = ClassType \"Bar\"}] ,methods = [MethodDef {mname = \"m\", mparams = [], mtype = IntType, mbody = VarAccess Nothing \"x\"}]} :} To type check the program, wrap it in a Program AST node and call the main type checking function: let program = Program [cls] tcProgram program Below we show helper functions, that the reader can copy-paste, and we build 5 examples of ASTs, where one of them also updates the compiler to throw multiple exceptions when doing binary operations, and show their equivalence in pseudo-code: (Do not forget to check tips on how to avoid mixing ASTs ) Helper Functions 1. Class with unbound variable 2. Class with two methods with unbound variable and unknown field errors 3. Updating the compiler to throw multiple errors in binary operations 4. Creating a new instance of a class that does not exist 5. Testing PhantomFunctors module","title":"Write your own program"},{"location":"Modelos/Relatorio/relatorio/#helper-functions-helper-func","text":"These helper functions are merely shorthand functions for not writing specific AST nodes. We believe these could be useful for less well-versed Haskell developers. We write also the type signature of these functions, so that the reader can look in the according AST from the module at test.^[We have used the String type, instead of Name , because the implementation is just an alias and think that it could be more helpful for the reader.] -- Class Factory: classFactory :: String -> [FieldDef] -> [MethodDef] -> ClassDef classFactory name fields methods = ClassDef name fields methods -- Field factory: fieldFactory :: Mod -> Name -> Type -> FieldDef fieldFactory modif name ty = FieldDef name ty modif -- Method factory methodFactory :: String -> [Param] -> Type -> Expr -> MethodDef methodFactory name params ty body = MethodDef name params ty body -- Parameter factory paramFact :: String -> Type -> Param paramFact name ty = Param name ty -- Field Access fieldAccess :: Expr -> String -> FieldAccess fieldAccess expr name = FieldAccess Nothing expr name -- Variable access varAccess :: String -> VarAccess varAccess nam = VarAccess Nothing nam -- Access to `this`. thisAccess :: VarAccess thisAccess = VarAccess Nothing thisName -- Binary operation binaryOp :: Op -> Expr -> Expr -> BinOp binaryOp op lhs rhs = BinOp Nothing op lhs rhs The reader should not copy these functions in the REPL, since the 5 following examples copy-paste the helper functions definitions^[The helper function definitions in some cases do not actually match the expected types, especially in the case of PhantomFunctors (and therefore also Final ). However, we provide a specific example for this module .]","title":"Helper Functions {#helper-func}"},{"location":"Modelos/Relatorio/relatorio/#1-class-with-unbound-variable-ex1","text":"This example tries to perform the sum on a variable ( y ) that has not been declared: class Object val x: Int -- immutable field def foo(): int this.x == y end end The following functions create the corresponding AST, which we test on the e.g., Backtrace module (feel free to copy-paste this in the REPL): :reload :m Backtrace.Typechecker Backtrace.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 1 above: paramsExample = [] bodyExample = binaryOp Add (fieldAccess thisAccess \"x\") (varAccess \"y\") methodsExample = [methodFactory \"foo\" paramsExample IntType bodyExample] fieldsExample = [fieldFactory Val \"x\" IntType] classesExample = classFactory \"Object\" fieldsExample methodsExample programExample1 = Program [classesExample] -- type checking of the program tcProgram programExample1 which outputs: Left *** Error during typechecking *** Unbound variable 'y' In expression y In expression this.x + y In method 'foo' In class 'Object'","title":"1. Class with unbound variable {#ex1}"},{"location":"Modelos/Relatorio/relatorio/#2-class-with-two-methods-with-unbound-variable-and-unknown-field-errors-ex2","text":"This example declares a class and two methods: foo and bar . The methods try to access an unbound variable and an unknown field. class Object def foo(): int this.x end def bar(): bool y end end As before, we the code below reloads the module, loads the Backtrace module, (re)defines the helper functions in the loaded module, and encodes the AST: :reload :m Backtrace.Typechecker Backtrace.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 2 above: paramsExample2 = [] methodsExample21 = methodFactory \"foo\" paramsExample2 IntType (fieldAccess thisAccess \"x\") methodsExample22 = methodFactory \"bar\" paramsExample2 IntType (varAccess \"y\") classesExample2 = classFactory \"Object\" [] [methodsExample21, methodsExample22] programExample2 = Program [classesExample2] -- type checking of the program tcProgram programExample2 The error is: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In method 'foo' In class 'Object' However, we can observe how there are actually two errors. To get the compiler to report all the errors, we can test the output of loading the MultiError module: :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 2 above: paramsExample2 = [] methodsExample21 = methodFactory \"foo\" paramsExample2 IntType (fieldAccess thisAccess \"x\") methodsExample22 = methodFactory \"bar\" paramsExample2 IntType (varAccess \"y\") classesExample2 = classFactory \"Object\" [] [methodsExample21, methodsExample22] programExample2 = Program [classesExample2] -- type checking of the program tcProgram programExample2 which now outputs both errors: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In method 'foo' In class 'Object' Unbound variable 'y' In expression y In method 'bar' In class 'Object'","title":"2. Class with two methods with unbound variable and unknown field errors {#ex2}"},{"location":"Modelos/Relatorio/relatorio/#3-updating-the-compiler-to-throw-multiple-errors-in-binary-operations-ex3","text":"In the current type checker, we only throw multiple exception in some cases. The reader can play with the code to extend it to places where one would expect to observe multiple errors. Let us handle throwing multiple errors when doing a binary operation, such as the following one: class Object def foo(): int this.x + y end end We would expect two errors, one for the unbound field this.x and one for the unbound variable y . Currently, we only throw one exception even when we load the MultiError module (please copy-paste the code below in the REPL): :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 3 above: paramsExample3 = [] bodyExample3 = binaryOp Add (fieldAccess thisAccess \"x\") (varAccess \"y\") methodsExample3 = [methodFactory \"foo\" paramsExample3 BoolType bodyExample3] classesExample3 = classFactory \"Object\" [] methodsExample3 programExample3 = Program [classesExample3] -- type checking of the program tcProgram programExample3 but the output only shows one error: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In expression this.x + y In method 'foo' In class 'Object' Lets update the type checking function on binary operations to handle this case. In the module MultiError.Typechecker.hs [ here ], we have the following type checking implementation for BinOp : doTypecheck e@(BinOp {op, lhs, rhs}) = do lhs' <- hasType lhs IntType rhs' <- hasType rhs IntType return $ setType IntType e{lhs = lhs' ,rhs = rhs'} Adding multiple errors is as simple as using the forking combinator as per the paper ( Sec. 6 ). The type signature for <&> is: (<&>) :: (Semigroup e, MonadError e m) => m a -> m b -> m (a, b) Since the function hasType ( hasType :: Expr -> Type -> TypecheckM Expr ) returns a monad, we can just apply two monadic actions (i.e., the call to hasType to the left-hand side and right-hand side) and aggregate the errors as follows: doTypecheck e@(BinOp {op, lhs, rhs}) = do (lhs',rhs') <- hasType lhs IntType <&> hasType rhs IntType return $ setType IntType e{lhs = lhs' ,rhs = rhs'} If we reload the module and re-run the example: :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 3 above: paramsExample3 = [] bodyExample3 = binaryOp Add (fieldAccess thisAccess \"x\") (varAccess \"y\") methodsExample3 = [methodFactory \"foo\" paramsExample3 BoolType bodyExample3] classesExample3 = classFactory \"Object\" [] methodsExample3 programExample3 = Program [classesExample3] -- type checking of the program tcProgram programExample3 the type checker now captures multiple errors even in this case: Left *** Error during typechecking *** Unknown field 'x' In expression this.x In expression this.x + y In method 'foo' In class 'Object' Unbound variable 'y' In expression y In expression this.x + y In method 'foo' In class 'Object'","title":"3. Updating the compiler to throw multiple errors in binary operations {#ex3}"},{"location":"Modelos/Relatorio/relatorio/#4-creating-a-new-instance-of-a-class-that-does-not-exist-ex4","text":"This example shows how to create a new instance of a class inside a method, which requires the use of a Let expression. In the surface language we do not expect developers to use Let expressions directly, and the parser would actually generate these bindings. The code below instantiates a non-existing class: class Object def foo(): Object let x = new C in x end end The code below reloads the module, (re)defines helper functions in the loaded module, and encodes the AST of the program above. :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 4 above: paramsExample4 = [] bodyExample4 = Let Nothing \"x\" (New Nothing (ClassType \"D\")) (VarAccess Nothing \"x\") methodsExample4 = [methodFactory \"foo\" paramsExample4 (ClassType \"Object\") bodyExample4] classesExample4 = classFactory \"Object\" [] methodsExample4 programExample4 = Program [classesExample4] -- type checking of the program tcProgram programExample4 The expected error is: Left *** Error during typechecking *** Unknown class 'D' In type 'D' In expression new D In expression let x = new D in x In method 'foo' In class 'Object' The reader can fix the current issue by creating a class that contains no fields nor methods, and named D . class D end class Object def foo(): Object let x = new D in x end end Below we reload the module and show the resulting AST: :reload :m MultiError.Typechecker MultiError.AST -- Helper functions being bound to the current AST module classFactory name fields methods = ClassDef name fields methods fieldFactory modif name ty = FieldDef name ty modif methodFactory name params ty body = MethodDef name params ty body paramFact name ty = Param name ty fieldAccess expr name = FieldAccess Nothing expr name varAccess nam = VarAccess Nothing nam thisAccess = VarAccess Nothing thisName binaryOp op lhs rhs = BinOp Nothing op lhs rhs -- Actual encoding of the example 4 above: paramsExample4 = [] bodyExample4 = Let Nothing \"x\" (New Nothing (ClassType \"D\")) (VarAccess Nothing \"x\") methodsExample4 = [methodFactory \"foo\" paramsExample4 (ClassType \"Object\") bodyExample4] classesExample4 = classFactory \"Object\" [] methodsExample4 programExample4 = Program [classesExample4, classFactory \"D\" [] []] -- type checking of the program tcProgram programExample4 The expected error is that the returned type of the method differs from the expected returned type, Object != D : Left *** Error during typechecking *** Type 'D' does not match expected type 'Object' In method 'foo' In class 'Object'","title":"4. Creating a new instance of a class that does not exist {#ex4}"},{"location":"Modelos/Relatorio/relatorio/#5-testing-phantomfunctors-and-final-module-ex5","text":"Testing the PhantomFunctors (and Final modules) requires a bit more work because we do no get the right algebraic data type in its expected 'Parsed kind. Reusing example 4 , which is the following program: class Object def foo(): Object let x = new C in x end end We show below the encoding of the AST, which requires the extension -XDataKinds , and the explicit type signatures that are given to the helper functions: :reload :set -XDataKinds :m Data.Proxy PhantomFunctors.Typechecker PhantomFunctors.AST :{ classFactory :: Name -> [FieldDef 'Parsed] -> [MethodDef 'Parsed] -> ClassDef 'Parsed classFactory name fields methods = ClassDef name fields methods fieldFactory :: Mod -> Name -> Type 'Parsed -> FieldDef 'Parsed fieldFactory modif name ty = FieldDef name ty modif methodFactory :: Name -> [Param 'Parsed] -> Type 'Parsed -> Expr 'Parsed -> MethodDef 'Parsed methodFactory name params ty body = MethodDef name params ty body paramFact :: Name -> Type 'Parsed -> Param 'Parsed paramFact name ty = Param name ty fieldAccess :: Expr 'Parsed -> Name -> Expr 'Parsed fieldAccess expr name = FieldAccess Proxy expr name varAccess :: Name -> Expr 'Parsed varAccess nam = VarAccess Proxy nam thisAccess :: Expr 'Parsed thisAccess = VarAccess Proxy thisName binaryOp :: Op -> Expr 'Parsed -> Expr 'Parsed -> Expr 'Parsed binaryOp op lhs rhs = BinOp Proxy op lhs rhs -- Actual encoding of the example 5 above: paramsExample5 = [] bodyExample5 = Let Proxy \"x\" (New Proxy (ClassType \"D\")) (varAccess \"x\") methodsExample5 = [methodFactory \"foo\" paramsExample5 (ClassType \"Object\") bodyExample5] classesExample5 = classFactory \"Object\" [] methodsExample5 programExample5 = Program [classesExample5] :} tcProgram programExample5 which outputs:^[There is no backtrace/stack trace because this module does not include the additions from the Backtrace module.] Left Unknown class 'D' ::: warning ::::::","title":"5. Testing PhantomFunctors and Final module {#ex5}"},{"location":"Modelos/Relatorio/relatorio/#information-how-to-avoid-mixing-asts-mixin-ast","text":"Upon loading a module, such as: :m MultiError.Typechecker MultiError.AST one creates programs that are tied to the MultiError.AST nodes. It is possible to mistakenly create new definitions that refer to different AST s, which will only fail upon trying to mix them. We recommend to remove all existing bindings when moving to a new module, and use the up-down arrows of the keyboard (in the REPL) to loop through entered definitions and reuse them (alternatively, one can have a file to keep these). For example: :reload :m Warning.Typechecker Warning.AST let program = Program [testClass1] -- User-defined function testClass1 = ClassDef {cname = \"C\",fields = [FieldDef {fmod = Val, fname = \"f\", ftype = ClassType \"Foo\"}],methods = []} -- add `testClass1` into the `Program` AST node. let program = Program [testClass1] -- Testing the function in the `Warning` module. tcProgram program -- some output of the errors. -- ... -- User would like to test output of a different -- type checker. The reader should reload project -- when moving to another module, which -- removes existing bindings. :reload :m MultiError.Typechecker MultiError.AST -- use up and down arrows until one finds -- the existing definition to re-test, here -- the `testClass1` testClass1 = ClassDef {cname = \"C\",fields = [FieldDef {fmod = Val, fname = \"f\", ftype = ClassType \"Foo\"}],methods = []} -- add `testClass1` into the `Program` AST node. let program = Program [testClass1] -- Test type checker, errors, warnigns, etc. tcProgram program ::::::::::::::::::::::::","title":"Information: how to avoid mixing ASTs {#mixin-ast}"},{"location":"Modelos/Relatorio/relatorio/#v-phantom-phases-phantom-phases","text":"This section can be thought as an intermediate step before Section 7. Refactoring: Type State Phases , and has been written as such. Its implementation is in typechecker-oopl/src/PhantomPhases , under Typechecker.hs and AST.hs 6.5. Refactoring: Phantom Phases It is really simple to introduce bugs in the compiler. For example, can you spot the error in the following function? instance Typecheckable Expr where typecheck e@(FunctionCall {target, args}) = do target' <- typecheck target let targetType = getType target unless (isArrowType targetType) $ throwError $ NonArrowTypeError targetType let paramTypes = tparams targetType resultType = tresult targetType args' <- zipWithM hasType args paramTypes return $ setType resultType e {target = target', args = args'} The error is in the line let targetType = getType target which tries to get the type of the current function from a node named target . However, target has not been type checked and does not have any typing information. Instead, the line should refer to the already type checked node, target' , which has been decorated with the typing information. A similar kind of bug is forgetting to decorate an expression with its type, which could cause errors in later stages of the compiler. In this section, we propose one solution to statically avoid these kind of bugs. The main idea is to use the Haskell type system to let the AST nodes track whether they have been type checked or not, so that we can prevent the use of undecorated AST nodes where we do not expect them. This will be implemented using phantom types.^[Matthew Fluet and Riccardo Pucella. 2006. Phantom types and sub-typing. J. Funct. Program. 16, 6 (2006). https://doi.org/10.1017/S0956796806006046] A full compiler goes through multiple phases. The type checker receives an undecorated AST node from the parsing phase, which then gets decorated during the type checking phase. Let us therefore reify the current phase in a data type: data Phase = Parsed | Checked Since we are aiming to use Parsed and Checked as phantom type parameters, the data type Phase needs to be lifted to the kind level. This can be done with the GHC extension DataKinds . With the extension KindSignatures , we can update the AST data types to take a phantom type of kind Phase : data Type (p :: Phase) = ClassType Name | IntType | BoolType | Arrow {tparams :: [Type p] ,tresult :: Type p} | UnitType deriving (Eq) newtype Program (p :: Phase) = Program [ClassDef p] deriving (Show) data ClassDef (p :: Phase) = ClassDef {cname :: Name ,fields :: [FieldDef p] ,methods :: [MethodDef p] } data Expr (p :: Phase) = BoolLit {etype :: Maybe (Type p) ,bval :: Bool} | Lambda {etype :: Maybe (Type p) ,params :: [Param p] ,body :: Expr p} | FieldAccess {etype :: Maybe (Type p) ,target :: Expr p ,name :: Name} | MethodCall {etype :: Maybe (Type p) ,target :: Expr p ,name :: Name ,args :: [Expr p]} | ... Note that a class definition is only considered Checked if all its fields and classes are Checked , and similarly for an expression and its subexpressions. Intuitively, the type of the type checking function for an expression is now going to be Expr 'Parsed -> Expr 'Checked , ensuring that we do not forget to check any expressions. Similarly, we change the type of a function like getType to Expr 'Checked -> Type 'Checked , ensuring that we only ever try to get the type of a decorated AST node. The entry point to the type checker must be updated, since it takes an undecorated program (with phantom type Parsed ) and returns either an error or a decorated program (with phantom type Checked ). An important change is that the environment used for type checking must only contain well-formed types. For example, if we use the environment to look up the type of a field, this field must not have an undefined type. Because of this, generating the environment can now fail if it finds an undefined type. Hence, we now require the use of the exception monad when building the environment: tcProgram :: Program 'Parsed -> Either TCError (Program 'Checked) tcProgram p = do env <- runExcept $ runReaderT (genEnv p) (generatePreEnv p) runExcept $ runReaderT (doTypecheck p) env Note that due to a chicken-and-egg problem, the environment Env can no longer contain full class definitions: in order to run the type checker we need a well-formed environment, but in order to get an environment containing well-formed classes we would need to run the type checker! Instead we change the environment to use special entries which only contain the (well-formed) types of classes, methods and fields. When building the environment, we use a simpler kind of environment which we dub a pre-environment which simply contains a list of all the valid class names, allowing us to check the well-formedness of types. We call the process of checking the types used by classes, fields and methods pre-checking , and use a type class scheme similar to the main type checker: class Precheckable a b where precheck :: a -> TypecheckM b Note that we reuse our type checking monad from before, including any of the previous extensions we might have added. For each kind of AST node a , we define an instance Precheckable a b which returns an entry of type b that can be used by the environment being generated. For example, pre-checking a class generates a ClassEntry , containing the (well-formed) types of all fields and methods: data MethodEntry = MethodEntry {meparams :: [Param 'Checked] ,metype :: Type 'Checked} data FieldEntry = FieldEntry {femod :: Mod ,fetype :: Type 'Checked} data ClassEntry = ClassEntry {cefields :: Map Name FieldEntry ,cemethods :: Map Name MethodEntry} data Env = PreEnv {classes :: [Name]} | Env {ctable :: Map Name ClassEntry ,vartable :: Map Name (Type 'Checked)} genEnv :: Program 'Parsed -> TypecheckM Env genEnv (Program classes) = do classEntries <- mapM precheck classes let cnames = map cname classes duplicates = cnames \\\\ nub cnames unless (null duplicates) $ throwError $ DuplicateClassError (head duplicates) return $ Env {vartable = Map.empty ,ctable = Map.fromList $ zip cnames classEntries} instance Precheckable (ClassDef 'Parsed) ClassEntry where precheck ClassDef {fields, methods} = do fields' <- mapM precheck fields methods' <- mapM precheck methods return ClassEntry {cefields = Map.fromList $ zip (map fname fields) fields' ,cemethods = Map.fromList $ zip (map mname methods) methods'} After pre-checking, we have a well-formed environment that we can use to type check the program just as before. The Typecheckable type class changes into: class Typecheckable a where typecheck :: a 'Parsed -> TypecheckM (a 'Checked) Thanks to phantom types, the Haskell compiler now helps us ensure that our type checking functions indeed return AST nodes which have been checked, and will statically notify us about the usage of undecorated AST nodes when one expects them to have typing information. Once more, the original implementation of the type checker did not change notably , we just added phantom types to some definitions and changed how we generate environments.","title":"v) Phantom Phases {#phantom-phases}"},{"location":"Modelos/Relatorio/relatorio/#3-how-to-extend-the-type-checker-extend-type-checker","text":"Here we document an overview on how to extend the type checker with subtyping, closely following the explanations of the paper ( Section 9 ). The first thing to consider is whether we need a new AST node to represent traits, which we do. Hence, we declare the TraitDecl node as well as their new dependencies ( Requirement AST node): data TraitDecl = Trait { tname :: Type, treqs :: [Requirement], tmethods :: [MethodDecl] } deriving (Show) data Requirement = RequiredField { rfield :: FieldDecl } | RequiredMethod { rmethods :: MethodDecl } deriving(Show) The TraitDecl has a field for the name of the trait, a list of requirements expected from the trait, and method declarations. The requirements could be imposed on fields ( RequiredField ) or methods ( RequiredMethod ). Now the parser can read a trait declaration and produce a TraitDecl AST node. The next thing to do is to extend the environment, so that the type checker can statically check subtyping properties between classes and traits. To do this, we extend the environment as follows (highlighted in blue in HTML): #cb36-2 { background: lightblue } data Env = Env {ctable :: Map Name ClassDef ,traittable :: Map Name TraitDecl ,vartable :: Map Name Type ,typeParameters :: [Type] ,bt :: Backtrace} After this change, we can type check a class and check that the required fields and methods of its trait are present, as per the following outline in the doTypecheck function: doTypecheck c@(Class {cname, cfields, cmethods, ctraits}) = do local addTypeVars $ mapM_ typecheck ctraits mapM_ isTraitType ctraits mapM_ (meetRequiredFields cfields) ctraits meetRequiredMethods cmethods ctraits ensureNoMethodConflict cmethods ctraits ... The following lines checks that traits are well-formed: local addTypeVars $ mapM_ typecheck ctraits mapM_ isTraitType ctraits After that, we check that the requirements of the traits apply to the current class, ensuring that there are no method conflicts (e.g.). As an example, this could be written as follows. mapM_ (meetRequiredFields cfields) ctraits meetRequiredMethods cmethods ctraits ensureNoMethodConflict cmethods ctraits","title":"3. How to extend the type checker {#extend-type-checker}"}]}